using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class BuildingResetting : MonoBehaviour {

	public static Vector3 _pos = new Vector3 ();
	public static Quaternion _quat = new Quaternion();
	
	public string message = "";
	public Text messageText;
	
	public string specifier;
	public bool activeInHierarchy;

	//idk what _updateCount is for
	public int _updateCount = 0;
	public int _messageCount = 0;

	GameObject feather;
	GameObject featherDestination;
	GameObject HUD;

	// Use this for initialization
	void Start () 
	{
		feather = GameObject.Find ("The Lead Feather");
		featherDestination = GameObject.Find ("FeatherDestination");
		HUD = GameObject.Find ("HUD");
		HUD.SetActive(false); 
		//test if steamvr position is in real life or virtual coordinates
	}
	
	// Update is called once per frame
	void Update () 
	{
		_updateCount++;
		_pos = Camera.main.transform.position;
		_quat = Camera.main.transform.rotation;
		//transform.eulerAngles = Camera.main.transform.eulerAngles; - IS THIS NEEDED ??????????????????
		Debug.Log (_pos);
		resettingFSM();
	}

	void OnGui()
	{
		//idk what to do here
	}

//beginning of the old code
	private Vector3 intendedCenter = new Vector3 (-30f, 8f, 30.9f);
	private float prevXAngle = 0f;
	private Vector3 prevPos = new Vector3();
	private bool resetNeeded = false;
	private bool hasNotReturnedToBounds = false;
	private float virtualAngleTurned = 0f; //each reset
	private float cumulativeAngleTurned = 0f; //total

	public void resettingFSM()
	{
		//Gather pertinent data
		Vector3 deltaTranslationByFrame = _pos - prevPos;
		specifier = "f4";
		//Debug.Log(string.Format("position: {0}, previous {1}", _pos, prevPos));
		//Debug.Log(string.Format("{0}: {1}", specifier, deltaTranslationByFrame.ToString(specifier)));
		float realWorldRotation = Camera.main.transform.eulerAngles.y;
		float deltaRotationByFrame = realWorldRotation - prevXAngle;
		//Debug.Log(string.Format("position: {0}, previous {1}", realWorldRotation, prevXAngle));
		//Debug.Log(string.Format("{0}: {1}", specifier, deltaRotationByFrame.ToString(specifier)));
		//if crossed threshold from + to - (1 to 359)
		if (deltaRotationByFrame > 90) {
			deltaRotationByFrame = deltaRotationByFrame - 360;
		}
		//if crossed threshold from - to + (359 to 1)
		else if (deltaRotationByFrame < -90) {
			deltaRotationByFrame = deltaRotationByFrame + 360;
		}

		//check to see if a reset is needed (only check if no reset has
		//	been triggered yet, and the subject has returned to inner bounds
		if (!resetNeeded && !hasNotReturnedToBounds && OutOfBounds ()) {
			resetNeeded = true;
			hasNotReturnedToBounds = true;
			virtualAngleTurned = 0f;
			feather.SetActive (true);
			if (feather.activeInHierarchy == true){
				Debug.Log (string.Format ("feather is active"));
			}
			Vector3 featherPosition = new Vector3 (featherDestination.transform.position.x, transform.position.y, featherDestination.transform.position.z);
			feather.transform.position = featherPosition;
			Vector3 featherEuler = new Vector3(90, featherDestination.transform.eulerAngles.y, 0);
			feather.transform.eulerAngles = featherEuler;
		}
		//perform reset by manipulating gain (to do this we will rotate the object in the opposite direction)
		else if (resetNeeded) {
			HUD.SetActive (true);
			if (HUD.activeInHierarchy == true) {
				Debug.Log (string.Format("HUD is active"));
			}
			//Calculate the total rotation neccesary - MIGHT BE MESSED UP BC NEGATIVE VECTOR FOR INTENDED CENTER
			float calc1 = Mathf.Rad2Deg * Mathf.Atan2 (intendedCenter.x - _pos.x, intendedCenter.z - _pos.z);
			Debug.Log (string.Format("calc1: {0}, realWorldRotation: {1}, rotationRemainingToCenter: {2}", calc1, realWorldRotation, rotationRemainingToCenter));
			float rotationRemainingToCenter = calc1 - realWorldRotation;
			//fix rotation variables
			if (rotationRemainingToCenter < -360) {
				rotationRemainingToCenter += 360;
			}
			if (rotationRemainingToCenter < -180) {
				rotationRemainingToCenter = 360 + rotationRemainingToCenter;
			}
			float rotationRemaningToCenterP = 0;
			float rotationRemaningToCenterN = 0;
			//determine left and right angles to rotate
			if (rotationRemainingToCenter < 0) {
				rotationRemaningToCenterN = rotationRemainingToCenter;
				rotationRemaningToCenterP = 360 + rotationRemainingToCenter;
			} else {
				rotationRemaningToCenterP = rotationRemainingToCenter;
				rotationRemaningToCenterN = rotationRemainingToCenter - 360;
			}

			//determine gain based on direction subject has rotated already
			//tuned so that at 360 virtual angle turned the person is pointing back to the center
			float gain = 0;
			Debug.Log(string.Format("virtual angle turned: {0}", virtualAngleTurned));
			if (virtualAngleTurned > 0) {
				gain = (360f - virtualAngleTurned) / rotationRemaningToCenterP - 1;
			} else {
				gain = -(360f + virtualAngleTurned) / rotationRemaningToCenterN - 1;
			}
			//inject rotation
			float injectedRotation = (deltaRotationByFrame) * gain;
			virtualAngleTurned += deltaRotationByFrame; //baseline turn
			Debug.Log(string.Format("virtual angle turned: {0}", virtualAngleTurned));
			virtualAngleTurned += injectedRotation; //amount we make them turn as well
			Debug.Log(string.Format("virtual angle turned: {0}, injectedRotation: {1}", virtualAngleTurned, injectedRotation));
			cumulativeAngleTurned -= injectedRotation; //to keep the person moving in the correct direction

			//I THINK THIS SECTION HAS THE ISSUE BC ROTATION ISN'T BEING "INJECTED" --> BC NO PARENT OBJECT?? 
			// ADDED Camera.main.transform. to new vector3 tmp because it gets the current location
			//add the injected rotation to the parent object
			Vector3 tmp = Camera.main.transform.eulerAngles;
			tmp.y += injectedRotation;
			Debug.Log(string.Format("tmp: {0}", tmp));
			transform.eulerAngles = tmp;
			//if a full turn has occured then stop resetting
			if (Mathf.Abs (virtualAngleTurned) > 359.9f || ReturnedToBounds()) {
				resetNeeded = false;
				HUD.SetActive (false);
			}
			message = "Please turn around";
		} 
		//Subject needs to walk forward two steps to prevent further triggers
		else if (hasNotReturnedToBounds) {
			if (ReturnedToBounds ()) {
				hasNotReturnedToBounds = false;
			}
			message = "Please walk forward";
			feather.SetActive (false);
			transform.Translate(deltaTranslationByFrame);
		}
		//General Operating
		else {
			message = "Please go to the destination";
			transform.Translate(deltaTranslationByFrame);
		}
		//update position incrementally using sin and cos
		//float delX = Mathf.Cos(cumulativeAngleTurned * Mathf.Deg2Rad) * deltaTranslationByFrame.x + Mathf.Sin(cumulativeAngleTurned * Mathf.Deg2Rad) * deltaTranslationByFrame.z;
		//float delZ = Mathf.Cos(cumulativeAngleTurned * Mathf.Deg2Rad) * deltaTranslationByFrame.z + Mathf.Sin(cumulativeAngleTurned * Mathf.Deg2Rad) * deltaTranslationByFrame.x;
		//transform.Translate(deltaTranslationByFrame);
		//store data for use next frame
		prevPos = _pos;
		prevXAngle = Camera.main.transform.eulerAngles.y;
		message = feather.transform.position.ToString();
	}
	
//NEW BOUNDARIES - used with new intended center
       public bool OutOfBounds() {
		if (_pos.x > -28.4f)
			return true;
		if (_pos.x < -31.1f)
			return true;
		if (_pos.z > 31f)
			return true;
		if (_pos.z < 26.8)
			return true;
		return false;
	}

	public bool ReturnedToBounds() {
		if (_pos.x > -28.7f)
			return false;
		if (_pos.x < -30.8f)
			return false;
		if (_pos.z > 30.7f)
			return false;
		if (_pos.z < 27.1f)
			return false;
		return true;
	}
}
