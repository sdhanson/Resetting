using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class BuildingResetting : MonoBehaviour {

	public static Vector3 _pos = new Vector3 ();
	public static Quaternion _quat = new Quaternion();
	
	public static string message;
	Text text;
	

	//idk what _updateCount is for
	public int _updateCount = 0;
	public int _messageCount = 0;

	GameObject feather;
	GameObject featherDestination;
	GameObject HUD;
	GameObject Rot;

	// Use this for initialization
	void Start () 
	{
		feather = GameObject.Find ("The Lead Feather");
		featherDestination = GameObject.Find ("FeatherDestination");
		HUD = GameObject.Find ("HUD");
		Rot = GameObject.Find("Rot");
	}
	
	// Update is called once per frame
	void Update () 
	{
		_updateCount++;
		_pos = Camera.main.transform.localPosition;
		resettingFSM();
	}

	void OnGui()
	{
		//text.text = message; 
	}

//beginning of the old code
	private Vector3 intendedCenter = new Vector3 (0f, 0f, 0f);
	private float prevXAngle = 0f;
	private Vector3 prevPos = new Vector3();
	private bool resetNeeded = false;
	private bool hasNotReturnedToBounds = false;
	private float virtualAngleTurned = 0f; //each reset
	private float cumulativeAngleTurned = 0f; //total

	public void resettingFSM()
	{
		//Gather pertinent data
		Vector3 deltaTranslationByFrame = _pos - prevPos;
		float realWorldRotation = Camera.main.transform.eulerAngles.y;
		float deltaRotationByFrame = realWorldRotation - prevXAngle;
		//if crossed threshold from + to - (1 to 359)
		if (deltaRotationByFrame > 90) {
			deltaRotationByFrame = deltaRotationByFrame - 360;
		}
		//if crossed threshold from - to + (359 to 1)
		else if (deltaRotationByFrame < -90) {
			deltaRotationByFrame = deltaRotationByFrame + 360;
		}

		//check to see if a reset is needed (only check if no reset has
		//	been triggered yet, and the subject has returned to inner bounds
		if (!resetNeeded && !hasNotReturnedToBounds && OutOfBounds ()) {
			resetNeeded = true;
			hasNotReturnedToBounds = true;
			virtualAngleTurned = 0f;
			feather.SetActive (true);
			Vector3 featherPosition = new Vector3 (featherDestination.transform.position.x, transform.position.y, featherDestination.transform.position.z);
			feather.transform.position = featherPosition;
			Vector3 featherEuler = new Vector3(90, featherDestination.transform.eulerAngles.y, 0);
			feather.transform.eulerAngles = featherEuler;
		}
		//perform reset by manipulating gain (to do this we will rotate the object in the opposite direction)
		//manipulating this part
		// so always want the person to be facing the center. want them to go from the angle they are facing out to the center --> can find the angle out from the center by doing arc tan to their position and then looking at their own position on their own coordinate field. then, want them to turn that whole way and the virtual world to turn 360 degrees. so look gain is the ratio of what is left to go in the real world to what is left to go in the virtual world (opposite ratio). say 300 in virtual and 100 in real --> gain is 3. so they turn 10 degrees and virtual they should turn 30, but vive takes care of the 10 real world so virtual should be 30 - 10 = 20. P and N are directions. need to check that calc is correct for the angles of the main camera and the angle back to the center and see why the turning is not right.
		else if (resetNeeded) {
			HUD.SetActive (true);
			float calc1 = Mathf.Rad2Deg * Mathf.Atan2 (intendedCenter.x - _pos.x, intendedCenter.z - _pos.z);
			float calc2 = realWorldRotation;
			if (_pos.x * _pos.z) > 0 {
				rotationRemainingToCenter= 180 + calc1 - calc2;
				rotationRemainingToCenterP = rotationRemainingToCenter;
				rotationRemainingToCenterN = 360 - rotationRemainingToCenter;
			}
			if (_pos.x * _pos.z) < 0 {
				rotationRemainingToCenter= calc1 + calc2;
				rotationRemainingToCenterP = rotationRemainingToCenter;
				rotationRemainingToCenterN = 360 - rotationRemainingToCenter;
			}

			//determine gain based on direction subject has rotated already
			//tuned so that at 360 virtual angle turned the person is pointing back to the center
			float gain = 0;
			if (virtualAngleTurned > 0) {
				gain = (360f - virtualAngleTurned) / rotationRemaningToCenterP - 1;
			} else {
				gain = -(360f + virtualAngleTurned) / rotationRemaningToCenterN - 1;
			}
			//inject rotation
			float injectedRotation = (deltaRotationByFrame) * gain;
			virtualAngleTurned += deltaRotationByFrame; //baseline turn
			virtualAngleTurned += injectedRotation; //amount we make them turn as well
			cumulativeAngleTurned -= injectedRotation; //to keep the person moving in the correct direction
 
			// ADDED Camera.main.transform. to new vector3 tmp because it gets the current location
			//add the injected rotation to the parent object
			Vector3 tmp = Camera.main.transform.eulerAngles;
			tmp.y += injectedRotation;
			transform.eulerAngles = tmp;
			//if a full turn has occured then stop resetting
			if (Mathf.Abs (virtualAngleTurned) > 359.9f || ReturnedToBounds()) {
				resetNeeded = false;
				HUD.SetActive (false);
			}
			message = "Please turn around";
		} 
		//Subject needs to walk forward two steps to prevent further triggers
		else if (hasNotReturnedToBounds) {
			if (ReturnedToBounds ()) {
				hasNotReturnedToBounds = false;
			}
			message = "Please walk forward";
			feather.SetActive (false);
			transform.Translate(deltaTranslationByFrame);
		}
		//General Operating
		else {
			message = "Please go to the destination";
			transform.Translate(deltaTranslationByFrame);
		}
		//update position incrementally using sin and cos
		//float delX = Mathf.Cos(cumulativeAngleTurned * Mathf.Deg2Rad) * deltaTranslationByFrame.x + Mathf.Sin(cumulativeAngleTurned * Mathf.Deg2Rad) * deltaTranslationByFrame.z;
		//float delZ = Mathf.Cos(cumulativeAngleTurned * Mathf.Deg2Rad) * deltaTranslationByFrame.z + Mathf.Sin(cumulativeAngleTurned * Mathf.Deg2Rad) * deltaTranslationByFrame.x;
		//transform.Translate(deltaTranslationByFrame);
		//store data for use next frame
		prevPos = _pos;
		prevXAngle = Camera.main.transform.eulerAngles.y;
		message = feather.transform.position.ToString();
	}
	
//NEW BOUNDARIES - used with new intended center
       public bool OutOfBounds() {
		if (_pos.x > 2.2f)
			return true;
		if (_pos.x < -0.34f)
			return true;
		if (_pos.z > 0.57f)
			return true;
		if (_pos.z < -2.68)
			return true;
		return false;
	}

	public bool ReturnedToBounds() {
		if (_pos.x > 1.9f)
			return false;
		if (_pos.x < -0.1f)
			return false;
		if (_pos.z > 0.27f)
			return false;
		if (_pos.z < -2.38f)
			return false;
		return true;
	}
}




OLD:
//fix rotation variables
			if (rotationRemainingToCenter < -360) {
				rotationRemainingToCenter += 360;
			}
			if (rotationRemainingToCenter < -180) {
				rotationRemainingToCenter = 360 + rotationRemainingToCenter;
			}
			float rotationRemaningToCenterP = 0;
			float rotationRemaningToCenterN = 0;
			//determine left and right angles to rotate
			if (rotationRemainingToCenter < 0) {
				rotationRemaningToCenterN = rotationRemainingToCenter;
				rotationRemaningToCenterP = 360 + rotationRemainingToCenter;
			} else {
				rotationRemaningToCenterP = rotationRemainingToCenter;
				rotationRemaningToCenterN = rotationRemainingToCenter - 360;
			}
